#! /bin/sh

# Copyright (c) 2009-2015, NVIDIA CORPORATION.  All rights reserved.
# See /etc/LICENSE file for details.

latest_minor_mods()
{
    local MAJOR
    local MINOR
    local DOT
    local VER
    MAJOR="$1"
    MINOR=`ls *$MAJOR*.tgz | sed "s/^E*[0-9]*\.// ; s/\..*//" | sort | tail -n 1`
    [ "$MINOR" ] || return
    VER="$MAJOR.$MINOR"
    DOT=`ls *$VER*.tgz | sed "s/^E*[0-9]*\.[0-9]*\.// ; s/\..*// ; s/^tgz$//" | sort | tail -n 1`
    [ "$DOT" ] && VER="$VER.$DOT"
    if [ -f "$VER.tgz" ]; then
        echo "$VER.tgz"
    elif [ -f "E$VER.tgz" ]; then
        echo "E$VER.tgz"
    fi
}

latest_mods()
{
    local MAJOR
    MAJOR=`ls *.tgz 2>/dev/null | grep "^E*[0-9][0-9][0-9]\.[0-9]*" | sed "s/^E// ; s/\..*//" | sort | tail -n 1`
    [ "$MAJOR" ] || return
    latest_minor_mods "$MAJOR"    
}

to_int()
{
    local HEX
    read HEX
    echo "$((0x$HEX))"
}

field()
{
    awk "{print \$$1}"
}

hex_field()
{
    field "$1" | to_int
}

best_mods_for_first_gpu()
{
    [ -f pcigpu.txt ] || return
    local DEVID
    DEVID=`/usr/sbin/lspci -n | grep "030[02]: 10de:" | head -n 1 | field 3 | cut -f 2 -d ':' | to_int`

    local ENTRY
    cat pcigpu.txt | while read ENTRY; do
        local FIRST
        local LAST
        local MAJOR
        FIRST=`echo "$ENTRY" | hex_field 1` 
        LAST=`echo "$ENTRY" | hex_field 2` 
        MAJOR=`echo "$ENTRY" | field 3` 
        if [ $DEVID -ge $FIRST -a $DEVID -le $LAST ]; then
            latest_minor_mods "$MAJOR"
            return
        fi
    done
}

die()
{
    echo -e "$@"
    exit 1
}

# Determine MODS package to use
LOCATION=`dirname "$0"`
[ -f "$LOCATION/pkgname" ] && PKGNAME=`tr -d '\r' < "$LOCATION/pkgname" | sed "/^ *$/d ; s/^ *// ; s/ *$//"`
[ -f "$LOCATION/$PKGNAME" ] || PKGNAME=`( cd "$LOCATION" ; best_mods_for_first_gpu )`
[ -f "$LOCATION/$PKGNAME" ] || PKGNAME=`( cd "$LOCATION" ; latest_mods )`
[ -f "$LOCATION/$PKGNAME" ] || PKGNAME="mods.tgz"
[ -f "$LOCATION/$PKGNAME" ] || die "MODS package not found\nPlease put MODS package name in pkgname file"

# Unpack MODS package to /tmp if needed
if [ ! -d "/tmp/$PKGNAME" ]; then
    echo "Unpacking $PKGNAME"
    mkdir "/tmp/$PKGNAME"
    tar xzf "$LOCATION/$PKGNAME" -C "/tmp/$PKGNAME"
fi

# Check if MODS executable exists
[ -x "/tmp/$PKGNAME/mods" ] || die "MODS executable not found in $PKGNAME"

# Check available disk space
AVAIL=`df -P -k . | tail -n 1 | tr -s ' ' | cut -d ' ' -f 4`
MINAVAIL="128"
[ "$MINAVAIL" -le "$AVAIL" ] || die "Only ${AVAIL}KB free left in $PWD - not enough to run MODS"

# Rename old mods.log
if [ -f "mods.log" ]; then
    DATE=`stat -c %y mods.log | sed "s/[-:]/ /g ; s/\..*//" | cut -d ' ' -f 2,3,4,5 | tr -d ' '`
    NEWNAME="$DATE.log"
    [ -f "$NEWNAME" ] && DATE=`mktemp "./$NEWNAME.XXXXXX"`
    echo "Renaming old mods.log to $NEWNAME"
    mv "mods.log" "$NEWNAME"
fi

# Run MODS
if [ $# -eq 0 -a -f args ]; then
    "/tmp/$PKGNAME/mods" "@args"
elif [ $# -eq 0 -a -f "$LOCATION/args" ]; then
    "/tmp/$PKGNAME/mods" "@$LOCATION/args"
else
    "/tmp/$PKGNAME/mods" "$@"
fi
