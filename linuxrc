#!/bin/sh

# Copyright (c) 2009-2019, NVIDIA CORPORATION.  All rights reserved.
# See /etc/LICENSE file for details.

VERSION="TINYLINUX_VERSION"
CONSOLE="/dev/console"
ROOTFS="/mnt/root"
MNTNV="mnt/nv"
MNTSQUASH="mnt/squash"
MNTETC="mnt/etc"
SQUASHFS_BIN="tiny/squash.bin"
NFSSHARE=""
NET="eth0"
COLDPLUG="1"

# Clear input and output
exec >${CONSOLE} <${CONSOLE} 2>&1

# Display startup info
echo -e "\033[1mBooting TinyLinux $VERSION\033[0m"

# Mount basic filesystems
mount -t proc     proc     /proc
mount -t sysfs    sysfs    /sys
mount -t devtmpfs devtmpfs /dev

# Install busybox symbolic links
/bin/busybox --install -s

# Save kernel boot time for later
KERNEL_BOOT_TIME=$(awk '{print $1*1000}' /proc/uptime)

# Prevent kernel logs from being sent to the console
dmesg -n 1

# Setup hotplug
# Use modprobe from busybox to avoid genkernel's modprobe sript
# which does not process module aliases.
echo '#!/bin/sh

[ "$ACTION" = "add" ] && busybox modprobe "$MODALIAS"' > /tmp/hotplug
chmod 755 /tmp/hotplug
echo /tmp/hotplug > /proc/sys/kernel/hotplug

# Allow overriding squash.bin location on the kernel command line
parse_opt()
{
    echo "$1" | cut -f 2- -d '='
}
for ARG in `cat /proc/cmdline`; do
    case "$ARG" in
        squash\=*)   SQUASHFS_BIN=`parse_opt "$ARG"` ;;
        partno\=*)   PARTNUMBER=`parse_opt "$ARG"` ;;
        nfsshare\=*) NFSSHARE=`parse_opt "$ARG"` ;;
        net\=*)      NET=`parse_opt "$ARG"` ;;
        nocoldplug)  COLDPLUG="" ;;
    esac
done

# Create root filesystem
mkdir -p "${ROOTFS}"
mount -t tmpfs tmpfs "${ROOTFS}"

# Coldplug
if [ "$COLDPLUG" = "1" ]; then
    ls /sys/bus/pci/devices/*/uevent /sys/bus/usb/devices/*/uevent /sys/block/*/uevent /sys/block/*/*/uevent | while read UEVENT; do
        echo "add" > "$UEVENT"
    done
fi

# Mount non-volatile volume or NFS share
mkdir -p "${ROOTFS}/${MNTNV}"
RETRYCOUNT=0
TRIEDDEVS=""
FOUNDDEV=""
while true; do
    if [ "$NFSSHARE" ]; then
        if [ -e "/sys/class/net/$NET" ]; then
            echo "Obtaining DHCP lease for $NET..."
            FOUNDDEV="$NET"
            ifconfig "$NET" up || exec /bin/sh
            udhcpc -n -T 1 -t 60 -q -i "$NET" || exec /bin/sh
            mount -t nfs -o nolock "$NFSSHARE" "${ROOTFS}/${MNTNV}" || exec /bin/sh
        fi
    else
        [ -z "$PARTNUMBER" ] || P_PARTNUMBER="p$PARTNUMBER"
        for DEVFILE in `find /dev/ -name "[sh]d[a-z]${PARTNUMBER}*" \
                                -o -name "sr${PARTNUMBER}*"         \
                                -o -name "nvme*n*${P_PARTNUMBER}*"`; do
            if ! echo "$TRIEDDEVS" | grep -q "$DEVFILE\>"; then
                if mount "$DEVFILE" "${ROOTFS}/${MNTNV}" 2>/dev/null; then
                    TRIEDDEVS="$TRIEDDEVS $DEVFILE"
                    if [ -f "${ROOTFS}/${MNTNV}/${SQUASHFS_BIN}" ]; then
                        echo "Found root device ${DEVFILE}"
                        FOUNDDEV="${DEVFILE}"
                        break
                    fi
                    umount "${ROOTFS}/${MNTNV}" || exec /bin/sh
                fi
            fi
        done
    fi
    [ "$FOUNDDEV" ] && break
    if [ $RETRYCOUNT -eq 0 ]; then
        [ "$NFSSHARE" ] && echo "Ethernet device $NET not found. Waiting..."
        [ -z "$NFSSHARE" ] && echo "Partition with root filesystem not found. Waiting..."
    fi
    WAITTIME=$(($(awk '{print $1*1000}' /proc/uptime) - $KERNEL_BOOT_TIME))
    [ $WAITTIME -gt 10000 ] && ( echo "Giving up..." && exec /bin/sh )
    RETRYCOUNT=$(($RETRYCOUNT+1))
done

# Mount squashed root filesystem
mkdir "${ROOTFS}/${MNTSQUASH}"
mount -t squashfs -o loop,ro "${ROOTFS}/${MNTNV}/${SQUASHFS_BIN}" "${ROOTFS}/${MNTSQUASH}"

# Check TinyLinux version in the squashed root filesystem
SQUASHFS_VERSION=$(head -n 1 "${ROOTFS}/${MNTSQUASH}/etc/release" | sed "s/.*version //")
if [ "$VERSION" != "$SQUASHFS_VERSION" ]; then
    echo "Installation error: initrd version $VERSION does not match squash.bin version $SQUASHFS_VERSION"
    echo "Unable to continue booting"
    exec /bin/sh
fi

# Create symlinks to the squashed root filesystem
cd "${ROOTFS}"
ln -s "${MNTSQUASH}"/* .
rm -f etc

# Create symlink to home dir
ln -s "${MNTNV}/home" home

# Set up etc
CONFIG_DIR="${ROOTFS}/${MNTNV}/`dirname "$SQUASHFS_BIN"`"
if [ ! -f "$CONFIG_DIR/config" ] && [ -f "$CONFIG_DIR/config.new" ]; then
    cp "$CONFIG_DIR/config.new" "$CONFIG_DIR/config" || echo "Error: Failed to copy config.new"
fi
mount_overlay()
{
    local ETCOVR
    if [ -f "$CONFIG_DIR/config" ]; then
        ETCOVR="${ROOTFS}/${MNTETC}"
        mkdir -p "$ETCOVR"
        mount -o loop "$CONFIG_DIR/config" "$ETCOVR" || return 1
    else
        ETCOVR=etc_overlay
        mkdir -p "$ETCOVR"
        echo "Persistent configuration not found, storing configuration in tmpfs"
    fi
    mkdir -p "${ETCOVR}/etc" "${ETCOVR}/work"
    if ! mount -t overlay -o lowerdir="${ROOTFS}/${MNTSQUASH}/etc",upperdir="${ETCOVR}/etc",workdir="${ETCOVR}/work" overlay etc; then
        [ -f "$CONFIG_DIR/config" ] && umount "$ETCOVR"
        rm -rf "$ETCOVR"
        return 1
    fi
    if [ -f "$CONFIG_DIR/config" ]; then
        cp "$CONFIG_DIR/config" "$CONFIG_DIR/config.bak"
    fi
}
mkdir etc
if ! mount_overlay; then
    echo "Error: Failed to mount configuration overlay"
    OVROK=0
    if [ -f "$CONFIG_DIR/config" ]; then
        mv "$CONFIG_DIR/config" "$CONFIG_DIR/config.bad"
        if [ -f "$CONFIG_DIR/config.bak" ]; then
            echo "Trying config.bak"
            cp "$CONFIG_DIR/config.bak" "$CONFIG_DIR/config"
        elif [ -f "$CONFIG_DIR/config.new" ]; then
            echo "Trying config.new"
            cp "$CONFIG_DIR/config.new" "$CONFIG_DIR/config"
        else
            echo "Trying config in ramdisk"
        fi
        if mount_overlay; then
            OVROK=1
        else
            echo "Error: Failed to mount backup configuration overlay"
        fi
    fi
    if [ "$OVROK" != "1" ]; then
        echo "Copying configuration to ramdisk"
        cp -a "${ROOTFS}/${MNTSQUASH}"/etc/* etc/
    fi
fi

# Mount boot partition
if [ "$PARTNUMBER" = "2" ] && [ -z "$NFSSHARE" ] && [ ! -f "${CONFIG_DIR}/kernel" ]; then
    mkdir "${ROOTFS}/boot"
    mount -o ro "${FOUNDDEV%2}1" "${ROOTFS}/boot"
fi

# Copy resolv.conf
[ "$NFSSHARE" ] && [ -f "/etc/resolv.conf" ] && cp /etc/resolv.conf etc/

# Create necessary directories
mkdir dev
mkdir proc
mkdir sys
mkdir tmp
chmod 1777 tmp
mkdir -p var/tmp
chmod 1777 var/tmp
mkdir var/log
chmod 755 var/log

# Create basic device nodes
mknod dev/null c 1 3
mknod dev/console c 5 1

# Unmount filesystems
umount /dev
umount /proc
umount /sys

# Copy mtab
sed "s/\/mnt\/root\//\// ; s/\/mnt\/root /\/ /" </etc/mtab >etc/mtab

# Store kernel boot time for reporting in /sbin/rc
echo "$KERNEL_BOOT_TIME" > var/log/kernel_boot_time

# Switch to the new root filesystem
exec /sbin/switch_root -c /dev/console "${ROOTFS}" /sbin/init
