#!/bin/sh

# Copyright (c) 2009-2016, NVIDIA CORPORATION.  All rights reserved.
# See /etc/LICENSE file for details.

__STATUSDIR="/var/rc/status"

# Dummy implementation for scripts which don't need either of these
start()
{
    /bin/true
}
stop()
{
    /bin/true
}

# Helper functions for network services
reachable()
{   
    ping -c 1 -q "$1" 2>&1
}
wait_reachable()
{
    local I
    for I in `seq $2`; do
        reachable "$1" && return 0
        sleep "$I"
    done
    return 1
}

# Get service status
__getstatus()
{
    local __STATUS
    __STATUS="stopped"
    [ -f "$__STATUSDIR/$1" ] && __STATUS=`cat "$__STATUSDIR/$1"`
    echo "$__STATUS"
}

# Start service dependencies
__startdeps()
{
    [ "$DEPENDS" ] || return 0

    local __DEP
    local __STATUS

    for __DEP in $DEPENDS; do
        __STATUS=`__getstatus "$__DEP"`
        if [ "$__STATUS" = "stopped" ]; then
            "/etc/init.d/$__DEP" silentstart || return $?
        fi
    done
}

# Get system uptime, in milliseconds
uptime_ms()
{
    awk '{print $1*1000}' /proc/uptime
}

# Convert time to seconds
time_in_s()
{
    local TIME
    TIME=$(($1/100))
    echo "$(($TIME/10)).$(($TIME%10))"
}

# Start service
__startservice()
{
    local RC
    local START_TIME
    local TIME

    __startdeps || return $?

    START_TIME=$(uptime_ms)

    if [ "$LOUDSERVICE" = "1" ]; then
        start
    else
        echo -n "Starting $__SVCNAME..."
        start > /dev/null
    fi
    RC=$?

    if [ $RC -eq 0 ]; then
        echo "$__SVCNAME" >> "$__STATUSDIR/.order"
        echo "started" > "$__STATUSDIR/$__SVCNAME"
    fi

    TIME="[$(time_in_s $(($(uptime_ms) - $START_TIME)))s]"

    if [ "$LOUDSERVICE" = "1" ]; then
        [ $RC -eq 0 ] || echo "Service $__SVCNAME failed to start"
    elif [ $RC -eq 0 ]; then
        echo " OK $TIME"
    else
        echo -e " \033[1;31mFAILED\033[0m $TIME"
    fi

    return $RC
}

# Stop service
__stopservice()
{
    local RC

    echo -n "Stopping $__SVCNAME..."
    stop > /dev/null
    RC=$?

    if [ $RC -eq 0 ]; then
        sed -i "/^$__SVCNAME\$/d" "$__STATUSDIR/.order"
        echo "stopped" > "$__STATUSDIR/$__SVCNAME"
        echo " OK"
    else
        echo -e " \033[1;31mFAILED\033[0m"
    fi

    return $RC
}

# Symlink files from conf dir (shallow)
__make_conf_symlinks()
{
    local FILE
    local SRC
    local DEST

    find "$1/" -maxdepth 1 -type f | while read FILE; do
        FILE=`basename "$FILE"`
        SRC="$TINYLINUXDIR/conf/$FILE"
        DEST="$1/$FILE"
        if [ -f "$SRC" ]; then
            echo "Linking $SRC to $DEST"
            tr -d '\r' < "$SRC" > /tmp/_doseol
            cat /tmp/_doseol > "$SRC"
            rm -f "$DEST"
            ln -s "$SRC" "$DEST"
        fi
    done
}

# Find TinyLinux configuration files
if [ -d "`/bin/tinydir`" ]; then
    TINYLINUXDIR="`/bin/tinydir`"
    export TINYLINUXDIR
fi

# Run a script
__SVCNAME=`basename "$1"`
if [ -x "/etc/init.d/$__SVCNAME" -a "$2" -a "$#" = 2 ]; then

    # Load config file
    __CFGFILE="/etc/conf.d/$__SVCNAME"
    [ -f "$__CFGFILE" ] && . "$__CFGFILE"

    # Load script file
    DEPENDS=""
    . "/etc/init.d/$__SVCNAME"

    # Get current status
    __STATUS=`__getstatus "$__SVCNAME"`

    # Execute command
    case "$2" in
        start|silentstart)
            if [ "$__STATUS" != "stopped" ]; then
                [ "$2" = "silentstart" ] || echo "Service $__SVCNAME is already started"
            else
                __startservice
            fi
            ;;

        stop)
            if [ "$__STATUS" = "stopped" ]; then
                echo "Service $__SVCNAME is already stopped"
            else
                __stopservice
            fi
            ;;

        restart)
            cp "$__STATUSDIR/.order" "$__STATUSDIR/.order_old"
            if [ "$__STATUS" != "stopped" ]; then
                __stopservice || exit $?
            fi
            __startservice || exit $?

            # Restore previous service order if service has started successfuly
            if grep -q "^$__SVCNAME\$" "$__STATUSDIR/.order_old"; then
                mv "$__STATUSDIR/.order_old" "$__STATUSDIR/.order"
            else
                rm "$__STATUSDIR/.order_old"
            fi
            ;;

        zap)
            sed -i "/^$__SVCNAME\$/d" "$__STATUSDIR/.order"
            echo "stopped" > "$__STATUSDIR/$__SVCNAME"
            ;;

        status)
            echo "status: $__STATUS"
            ;;
    esac

# Overall status
elif [ "$1" = "status" ]; then
    find /etc/init.d/ -type f | sort | while read __SVC; do
        __SVCNAME=`basename "$__SVC"`
        __STATUS=`__getstatus "$__SVCNAME"`
        echo "$__SVCNAME: $__STATUS"
    done

# Enable services
elif [ "$1" = "enable" ]; then

    shift
    while [ $# -gt 0 ]; do

        # Check if such service exists
        if [ ! -f "/etc/init.d/$1" ]; then
            echo "Service $1 not found!"
            exit 1
        fi

        # Attempt to start the service
        /etc/init.d/$1 start || exit $?

        # Prepare boot list
        if echo "$TINYLINUXDIR" | grep -q "/mnt/nv"; then
            mkdir -p "$TINYLINUXDIR/conf"
            if [ ! -f "$TINYLINUXDIR/conf/boot" ]; then
                cp /etc/conf.d/boot "$TINYLINUXDIR/conf"/
                rm /etc/conf.d/boot
                ln -s "$TINYLINUXDIR/conf/boot" /etc/conf.d/boot
            fi
            if [ ! -f "$TINYLINUXDIR/conf/$1" -a -f "/etc/conf.d/$1" ]; then
                cp "/etc/conf.d/$1" "$TINYLINUXDIR/conf"/
                rm "/etc/conf.d/$1"
                ln -s "$TINYLINUXDIR/conf/$1" "/etc/conf.d/$1"
            fi
        fi

        # Add service to boot list
        echo "$1" >> /etc/conf.d/boot

        # Next service
        shift
    done

# Disable services
elif [ "$1" = "disable" ]; then

    shift
    while [ $# -gt 0 ]; do

        # Check if such service exists
        if [ ! -f "/etc/init.d/$1" ]; then
            echo "Service $1 not found!"
            exit 1
        fi

        # Attempt to stop the service
        /etc/init.d/$1 stop

        # Remove service from boot list
        sed -i "/^$1$/d" /etc/conf.d/boot

        # Next service
        shift
    done

# System init
elif [ "$1" = "sysinit" ]; then

    # Remount root as rw if necessary
    mount -t proc none /proc
    if grep -q " rootfs.*ro" /proc/mounts; then
        echo "Remounting root read-write"
        mount -o remount,rw rootfs /
    fi

    # Mount basic filesystems
    mount -t sysfs none /sys
    mount -t devtmpfs -o "mode=0755" udev /dev
    [ -d /dev/pts ] || mkdir -m 0755 /dev/pts
    [ -d /dev/shm ] || mkdir -m 1777 /dev/shm
    mount -t devpts -o "mode=0620,gid=5" devpts /dev/pts

    # Setup hotplug
    touch /dev/mdev.seq
    echo "/sbin/mdev" > /proc/sys/kernel/hotplug

    # Coldplug devices
    if ! grep -q "nocoldplug" /proc/cmdline; then
        ls /sys/bus/pci/devices/*/uevent /sys/bus/usb/devices/*/uevent /sys/block/*/uevent /sys/block/*/*/uevent | while read UEVENT; do
            echo "add" > "$UEVENT"
        done
    fi

# Boot services
elif [ "$1" = "boot" ]; then

    # Measure time
    START_TIME=$(uptime_ms)

    # Create status directory
    [ -d "$__STATUSDIR" ] && rm -rf "$__STATUSDIR"
    mkdir -p "$__STATUSDIR"

    # Create run directory
    [ -d /run ] || mkdir /run
    [ -e /var/run ] || ln -s /run /var/run

    # Remove stale files from before boot
    rm -f /var/run/*

    # Create persistent configuration directory if it does not exist
    echo "$TINYLINUXDIR" | grep -q "/mnt/nv" && mkdir -p "$TINYLINUXDIR/conf"

    # Symlink configuration files
    __make_conf_symlinks /etc/conf.d
    __make_conf_symlinks /etc

    # Mount debug fs if it is available
    grep -q debugfs /proc/filesystems && [ -d /sys/kernel/debug ] && mount -t debugfs none /sys/kernel/debug

    # Start boot services
    cat "/etc/conf.d/boot" | while read __SVCNAME; do
        if [ -f "/etc/init.d/$__SVCNAME" ]; then
            "/etc/init.d/$__SVCNAME" silentstart
        else
            echo "Service $__SVCNAME not found"
        fi
    done

    # Display boot time statistics
    TOTAL_BOOT_TIME=$(uptime_ms)
    if [ -f /var/log/kernel_boot_time ]; then
        KERNEL_BOOT_TIME=$(cat /var/log/kernel_boot_time)
    else
        KERNEL_BOOT_TIME=$START_TIME
    fi
    INIT_TIME=$(($START_TIME - $KERNEL_BOOT_TIME))
    SERVICES_BOOT_TIME=$(($TOTAL_BOOT_TIME - $START_TIME))
    echo "[kernel $(time_in_s $KERNEL_BOOT_TIME)s, init $(time_in_s $INIT_TIME)s, services $(time_in_s $SERVICES_BOOT_TIME)s, total $(time_in_s $TOTAL_BOOT_TIME)s]"

# Shutdown
elif [ "$1" = "shutdown" ]; then
    tac < "$__STATUSDIR/.order" | while read __SVCNAME; do
        "/etc/init.d/$__SVCNAME" stop
    done
    sync

else
    echo "Invalid command"
fi
